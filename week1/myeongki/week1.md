# 3장
- 아키텍처 경계를 넘나들기 위한 메커니즘으로 다형성을 이용
- 함수형 프로그래밍을 이용하여 데이터의 위치와 접근 방법에 대해 규칙을 부과한다.
- 모듈 기반 알고리즘으로 구조적 프로그래밍을 사용한다.

# 4장 구조적 프로그래밍 
## 증명
- 데이크스트라는 연구를 진행하면서 goto 문장이 모듈을 더 작은 단위로 재귀적으로 분해하는 과정에 방해가 되는 경우가 있다는 사실을 발견했다. 만약 모듈을 분해할 수 없다면 합리적으로 증명할 때 필수적인 기법인 분할 정복 접근법을 사용할 수 없게 된다.
- 순차, 분기, 반복이라는 3가지 구조만으로 표현할 수 있다는 사실을 증명하였고 모듈을 증명 가능하게 하는 바로 그 제어 구조가 모든 프로그램을 만들 수 있는 제어 구조의 최소 집합과 동일하다는 사실이었다.
- 수학적 증명은 실패


## 과학적 증명
- 과학적 이론과 법칙이 지닌 본성은 반증은 가능하지만 증명은 발가능하다고 보면된다.
- 소프트웨어 개발은 수학적인 시도가 아니라는 과학과 같다.(테스트 이야기.. 테스트 코드를 통하여 해당 코드에 버그가 없음을 증명할 수는 없지만 버그가 있음만을 보여줄 뿐이다.)

## 결과적으로 goto가 사라지는 과정과 소프트웨어는 과학에 가깝다는 내용.

# 5장 객체 지향
## 갭슐화
- 구분선 바깥에서 데이터는 은닉되고, 일부 함수만이 외부에 노출된다.
- 실제로는 c언어에서 누렸던 완벽한 캡슐화를 약화시켜 온 것은 틀림없다.

## 상속
- 상속이란 단순히 어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의하는 일에 불과하다.
- c에서도 가능..

## 다형성
- 다형성이란 프로그램 언어 각 요소들(상수, 변수, 식, 객체, 메소드 등)이 다양한 자료형(type)에 속하는 것이 허가되는 성질을 가리킨다. 
- 함수를 가리키는 포인터를 응용한 것이 다형성이라는 점이다.
- c에서도 쓸 수 있다.(어려움)

### 제어흐름을 간접적으로 전환하는 규칙을 부과한다고 결론지을 수 있다.

## 플로그인 아키텍쳐(다형성이 가진 힘)
- 장치에 의존적인 수많은 프로그램을 만들고 나서야, 이들 프로그램이 다른 장치에서도 동일하게 동작할 수 있도록 만드는 것이 우리가 진정 바랐던 일임을 깨달음 (천공카드 -> 테이프 이야기)

## 의존성 역전
- 다형성을 쉽게 적용할 수 있데 됨에 따라서 의존성 역전을 쉽게 사용할 수 있게 됨.
- ui와 데이터베이스가 업무 규칙의 플러그인이 된다는 뜻.
- 특정 컴포넌트의 소스코드가 변경되면 해당 코드가 포함된 컴포넌트만 다시 배포하면 된다. 이것이 바로 배포 독립성
- 시스템의 모듈을 독립적으로 배포할 수 있게 되면 서로 다른 팀에서 각 모듈을 독립적으로 개발할 수 있다. 그리고 이것이 개발 독립성

