# 15장 아키텍처란?
- 아키텍처의 주된 목적은 생명주기를 지원하는 것이다. 좋은 아키텍처는 시스템을 쉽게 이해하고, 쉽게 개발하며, 쉽게 유지보수하고, 또 쉽게 배포하게 해준다. 아키텍처의 궁극적인 목표는 시스템의 수명과 관련된 비용은 최소화하고, 프로그래머의 생산성은 최대화하는데 있다.

## 운영
- 아키텍처가 시스템 운영에 미치는 영향은 개발, 배포, 유지보수에 미치는 영향 보다는 덜 극적이다.
- 좋은 소프트웨어 아키텍처는 시스템을 운영하는데 필요한 요구도 알려준다.
- 시스템 아키텍처는 유스케이스, 기능, 시스템의 필수 행위를 일급 엔티티로 격상시키고, 이들 요소가 개발자에게 주요 목표로 인식되도록 해야 한다. 이를 통해 시스템을 이해하기 쉬워지며, 따라서 개발과 유지보수에 큰 도움을 준다.

## 유지보수
- 아키텍처를 신경을 쓰면은 유지보수 비용이 줄어든다.

## 선택사항 열어 두기
- 소프트웨어를 부드럽게 유지하는 방법은 선택사항을 가능한 한 많이 그리고 가능한 한 오랫동안 열어 두는 것이다.
- 정책과 세부사항으로 분해하기
- 세부사항은 사람, 외부 시스템, 프로그래머가 정책과 소통할 때 필요한 요소지만, 정책이 가진 행위에는 조금도 영향을 미치지 않는다.
- 아키택트의 목표는 시스템에서 정책을 가장 핵심적인 요소로 식별하고, 동시에 세부사항은 정책에 무관하게 만들 수 있는 형태의 시스템을 구축하는 데 있다.이를 통하여 결정하는 일은 미루거나 여기할 수 있게 된다.

### ex
- 개발 초기에는 데이터베이스 시스템을 선택할 필요가 없다.
- 개발 초기에는 웹 서버를 선택할 필요가 없다.
- 개발 초기에는 REST를 적용할 필요가 없다.
- 개발 초기에는 의존성 주입 프레임워크를 적용할 필요가 없다.

### 좋은 아키텍트는 결정되지 않은 사항의 수를 최대화한다.

# 16장 독립성
## 좋은 아키텍처는 다음을 지원해야한다.
- 시스템의 유스케이스
- 시스템의 운영
- 시스템의 개발
- 시스템의 배포

## 유스케이스
- 시스템의 아키텍처는 시스템의 의도를 지원해야 한다.
- 좋은 아키텍처가 행위를 지원하기 위해 할 수 있는 일 중에서 가장 중요한 사항은 행위를 명확히 하고 외부로 드러내며, 이를 통해 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있게 만드는 것이다.

## 운영
- 만일 시스템이 단일체로 작성되어 모노리틱 구조를 갖는다면, 다중 프로세스, 다중 스레드, 또는 마이크로서비스 형태가 필요해질 때 개선하기가 어렵다. 그에 비해 아키텍처에서 각 컴포넌트를 적절히 격리하여 유지하고 컴포넌트 간 통신 방식을 특정 형태로 제한하지 않는다면, 시간이 지나 운영에 필요한 요구사항이 바뀌더라도 스레드, 프로세스, 서비스로 구성된 기술 스펙트럼 사이를 전환하는 일이 훨씬 쉬워질 것이다.

## 개발
- 각 팀이 독립적으로 행동하기 편한 아키텍처를 반드시 확보하여 개발하는 동안 팀들이 방해지 않도록 해야 한다.

## 배포
- 좋은 아키텍처라면 시스템이 빌드된 후 즉각 배포할 수 있도록 지원해야 한다.

## 선택사항 열어놓기
- 좋은 아키텍처는 선택사항을 열어 둠으로써, 향후 시스템에 변경이 필요할 때 어떤 방향으로든 쉽게 변경할 수 있도록 한다.

## 계층 결합 분리
- 계층 분리의 예로 UI, 비즈니스 로직, 어플리케이션과 독립적인 업무 규칙(DB) 이렇게 분리할 수 있다.

## 유스케이스 결합 분리
- 유즈케이스는 시스템을 분할하는 매우 자연스러운 방법이다.
- 유스케이스를 뒷받침하는 ui와 데이터베이스를 서로 묶어서 각 유스케이스가 ui와 데이터베이스의 서로 다른 관점을 사용하게 되면, 새로운 유스케이스를 추가하더라도 기존 유스케이스에 영향을 주는 일은 거의 없을 것이다.

## 결합 분리 모드
- 간단히 말해 유스케이스를 위해 수행하는 그 작업들은 운영에 도움이 된다.
- 분리된 컴포넌트를 서로 다른 서버에서 실행해야 하는 상황이라면, 이들 컴포넌트가 단일 프로세서의 동일한 주소 공간에 함께 상주하는 형태로 만들어져서는 안 된다. 분리된 컴포넌트는 반드시 독립된 서비스가 되어야 하고, 일종의 네트워크를 통해 서로 통신해야 한다.
- 컴포넌트를 서비스 수준까지도 분리해야한다는 것이다.

## 중복
- 중복인 두 코드 영역이 각자의 경로로 발전하다면, 즉 서로 다른 속도와 다른 이유로 변경된다면 이 두 코드는 진짜 중복이 아니다.
- 진짜 중복만 지우자..

## 결합 분리 모드
- 소스 수준 분리 모드
- 배포 수준 분리 모드
- 서비스 수준 분리 모드
- 좋은 아키텍처는 시스템이 모노리틱 구조로 태어나서 단일 파일로 배포되더라도, 이후에는 독립적으로 배포 가능한 단위들의 집합으로 성장하고, 또 독립적인 서비스나 마이크로서비스 수준까지 성장할 수 있도록 만들어져야 하낟.

### 뛰어난 아키텍트라면 이러한 변경을 예측하여 큰 무리 없이 반영할 수 있도록 반들어야 한다는 점이다.

# 17장 경계 선 긋기

- 너무 빠른 시스템 결정으로 불필요한 비용을 지불한 사례 (서버 팜의 지원이 아직 결정되지 않았고 이런 서버팜이 필요할거라 예측하여 불필요한 리소스를 낭비한 사례)

## 어떻게 선을 그을까? 그리고 언제 그을까?
- 데이터 베이스는 업무 규칙이 간접적으로 사용할 수 있는 도구다. 업무 규칙은 스키마, 쿼리 언어, 또는 데이터베이스와 관련된 나머지 세부사항에 대해 어떤 것도 알아서는 안된다. 업무 규칙이 알아야 할 것은 데이터를 가져오고 저장할 때 사용할 수 있는 함수 집합이 있다는 사실이 전부다.

- 비즈니스룰에 데이터베이스 인터페이스를 포함 시켜서 보면 이를 다시 컴포넌트롤 확대하여 해석하면 데이터베이스 컴포넌트는 비즈니스 룰 컴포넌트에 의존하게 되고 즉 비즈니스 룰에 다른 데이터 베이스를 연결할 수 있게 된다.(GUI도 비슷하게 해석 가능)

### 시스템을 플러그인 아키텍처로 배치함으로써 변경이 전파될 수 없는 방화벽을 생성할 수 있다. 
