# 5장 함수형 프로그래밍
## 불변성과 아키텍쳐
- 가변성을 염려하는 이유는 경합조건, 교착상태 조건, 동시 업데이트 모두가 가변 변수로 인해 밸생.
- 무한한 자원이 없기 때문에 타협이 필요

## 가변성의 분리
- 가변 컴포넌트와 불변 컴포넌트로 분리하자.
- atom을 사용하여 일부는 해결 가능하지만.. 완벽하게 해결은 불가능
- 결국 최대한 불변 컴포넌트로 옮기자..

## 이벤트 소싱
- 트랜잭션을 계속 올려두는 방식으로 진행하면 무한한 자원이 필요하지만 이것이 영원히 동작하도록 만들 필요는 없다. 아마도 애플리케이션의 수명주기 동안만 문제 없이 동작할 정도의 저장공간과 처리 능력만 있으면 충분할 것이다.
- 이벤트 소싱에 깔려있는 기본 발상이 바로 이것이다. 이벤트 소싱은 상태가 아닌 트랜잭션을 저장하자는 전략이다. 상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리한다.

## 정리
- 구조적 프로그래밍은 제어흐름의 직접적인 전환에 부과되는 규율이다.
- 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 부과되는 규율이다.
- 함수형 프로그래밍은 변수 할당에 부과되는 규율이다.


- 프로그램은 순차, 분기, 반복, 참조로 구성된 그 이상도 이하도 아니다.

# 단일 책임 원칙
- 하나의 모듈은 하나의 오직 하나의 사용자 또는 이해관계자에 대해서만 책임져야한다. (모든 모듈이 단 하나의 일만 해야 한다는 의미로 받아 들여지기 쉽다. X 적절하지 않다.)
- Employee class에 caculatePay, reportHours, save 이렇게 3개의 함수가 있다하자 이 기능을 원하는 곳이 3곳(회계 인사 데이터 베이스 관리자) 3명의 엑터에 결합되어 단일 책임 원칙에 깨진다. 즉 SRP는 서로 다른 액터가 의존하는 코드를 서로 분리하라고 말한다.

## 해결
- 아무런 메서드가 없는 간단한 데이터 구조인 employeeData 클래스를 만들어 세 개의 클래스가 공유하도록 한다. 각 클레스는 자신의 메서드에 반드시 필요한 소스코드만을 포함한다. -> 세가지 클래스를 인스턴스화하고 추적해야한다는게 단점이다.
- 퍼사드 패턴을 통하여 개선하자.. 세 클레스의 객체를 생성하고 요청된 메서드를 가지는 객체로 위임하는 일을 책임지자.
- 또는 가장 중요한 메서드는 기존의 employee 클래스에 유지하되 employee 클래스를 덜 중요한 나머지 매서드들에 대한 퍼사드로 사용

# OCP 개발 폐쇄 원칙
- 소프트웨어 개체의 행위는 확장할 수 있어야 하지만 이때 개체를 변경해서는 안된다,
- a컴포넌트에서 b컴포넌트를 보호하려면 반드시 A컴포넌트가 b컴포넌트에 의존해야 한다.
- a를 변경해도 b는 a를 모르기 때문에.. b를 a의 변경으로부터 보호할 수 있다.
- 이게 아키텍쳐 수준에서 ocp가 동작하는 방식이다.

## 추이 종속성
- 연속적으로 의존도가 생기는 것-> 그러므로 인터페이스를 통하여 정보 은닉 -> 자신이 직접 사용하지 않는 요소에는 절대로 의존하지 않도록하기 위하여.

## 결론
- 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야 한다.