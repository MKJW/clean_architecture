# 18장 경계 해부학

## 경계 횡단하기
- 소스코드 모듈 하나가 변경된면, 이에 의존하는 다른 소스코드 모듈도 변경하거나, 다시 컴파일해서 새로 배포해야 할지도 모르기 때문이다. 경계는 이러한 변경이 전파되는 것을 막는 방화벽을 구축하고 관리하는 수단으로써 존재한다.

## 두려운 단일체
- 가장 단순한 형태의 경계 횡단은 저수준 클라이언트에서 고수준 서비스로 향하는 함수 호출이다. 이 경우 런타임 의존성과 컴파일타임 의존성은 모두 같은 방향 즉 저수준 컴포넌트에서 고수준 컴포넌트로 향한다.(ex 구현체는 저수준 컴포넌트에, 데이터와 인터페이스는 고수준에 위치 시키면 방향성을 저수준에서 고수준을 향하도록 만들 수 있다.)

## 배포형 컴포넌트
- 경계가 물리적으로 드러날 수도 있는데 그중 가장 단순한 형태는 동적 링크 라이브러리다.
- 단일체와 마찬가지로 배포형 컴포넌트의 경계를 가로지르는 통신은 순전히 함수 호출에 지나지 않으므로 매우 값싸다. 동적 링크와 런타임 로딩으로인해 최초의 호출은 오래 걸릴 수 있지만, 대체로 이들 경계를 가로지르는 통신은 매우 빈번할 것이다.

## 스레드
- 모든 스레드가 단 하나의 컴포넌트에 포함될 수도 있고, 많은 컴포넌트에 걸쳐 분산될 수도 있다.

## 로컬 프로세스
- 주로 명령행이나 그와 유사한 시스템 호출을 통해 생성된다. 로컬 프로세스들은 동일한 프로세서 또는 하나의 멀티코어 시스템에 속한 여러 프로세서들에서 실행되지만, 각각이 독립된 주소 공간에서 실행된다. 
- 로컬 프로세스를 일종의 최상위 컴포넌트라고 생각하자. 즉 로컬 프로세스는 컴포넌트 간 의존성을 동적 다형성을 통해 관리하는 저수준 컴포넌트로 구성된다.
- 데이터 마샬링 및 언마샬링, 프로세스 간 문맥 교환 등이 로컬 프로세스간 통신이며 비용이 꽤 비쌈

## 서비스
- 물리적인 형태를 띠는 가장 강력한 경계는 바로 서비스다.
- 서비스들은 모든 통신이 네트워크를 통해 이뤄진다고 가정한다.

# 19장 정책과 수준

### 소프트웨어 시스템이란 정책을 기술한 것이다.

## 수준
- 수준을 엄밀하게 정의하자면 입력과 출력가지의 거리다.
- 입출력과 멀리 위치할수록 정책의 수준은 높아진다.

# 업무규칙
## 엔티티
- 컴퓨터 시스템 내부의 객체로서 핵심 업무 데이터를 기반으로 동작하는 일련의 조그만 핵심 업무 규칙을 구체화한다.
- 데이터베이스, 사용자 인터페이스, 서드파티 프레임워크에 대한 고려사항들로 인해 오염되어서는 절대 안 된다.
- 핵심업무 데이터와 핵심 업무 규칙을 하나로 묶어서 별도의 소프트웨어 모듈로 만들어야 한다는 것이다.

## 유스케이스
- 모든 업무 규칙이 엔티티처럼 순수한 것은 아니다. 자동화된 시스템이 동작하는 방법을 정의하고 제약함으로써 수익을 얻거나 비용을 줄이는 업무 규칙도 존재한다.
- 자동화된 시스템이 사용되는 방법을 설명한다.
- 엔티티 내의 핵심 업무 규칙과는 반대로 유스케이스는 애플리케이션에 특화된 업무 규칙을 설명한다.
- 유즈케이스는 엔티티 내부의 핵심 업무 규칙을 어떻게 그리고 언제 호출할지를 명시하는 규칙을 담는다. 엔티티가 어떻게 춤을 출지를 유스케이스가 제어하는 것이다.
- 유즈케이스만 봐서는 이 애플리케이션이 웹을 통해 전달되는지, 리치 클라이언트인지, 콘솔 기반인지, 아니면 순수한 서비스인지를 구분하기란 불가능하고 이는 중요하다.
- 애플리케이션에 특화된 규칙을 설명하며 이를 통해 사용자와 엔티티 사이의 상호작용을 규정한다.
- 시스템에서 데이터가 들어오고 나가는 방식은 유스케이스와는 무관하다.
- 왜 엔티티는 고수준이며 유스케이스는 저수준일까? 왜냐하면 유슴케이스는 단일 애플리케이션에 특화되어 있으며 따라서 해당 시스템의 입력과출력에 보다 가갑게 위치하기 때문이다. 엔티티는 수많은 다양한 애플리케이션에서 사용될 수 있도록 일반화된 것이므로, 각 시스템의 입력이나 출력에서 더 멀리 떨어져 있다.
- 유스케이스는 엔티티에 의존한다. 반면 엔티티는 유스케이스에 의존하지 않는다.
















