# 9장 리스코프 치환 원칙

## 라이센스 문제
- billing 애플리케이션의 행위가 license 하위 타입(personal license, business license) 중 무엇을 사용하는지에 전혀 의존하지 않기 때문에 LSP를 잘 준수하고 있다.

## 정사각형 직사각형 문제
- 직사각형 하위로 정사각형을 넣는건 적합하지 않다. rectangle의 높이와 너비는 서로 독립적으로 변경될 수 있는 반면 square의 높이와 너비는 반드시 함께 변경되기 때문. 
- 해결방법은 사용처에서 해당 사각형이 직사각형인지 정사각형인지 구분하는 분기 추가 -> 사용하고자하는 타입에 의존하게 되므로 결국 타입을 서로 치환할 수 없게 된다.

## LSP 위배 사례
- 택시 rest api 예를 통하여 uri에 택시 정보를 담는 과정에서 치환이 불가능한 구조로 rest를 만들면 나중에 코드상에서 분기를 쳐야하는 경우가 말생하고 결국 전반적으로 프로그램을 오염시킨다.

## 결론
- lsp는 아키텍쳐 수준까지 확장할 수 있고 반드시 확장해야한다. 치환 가능성을 조금이라도 위배하면 시스템 아키택처가 오염되어 상당량의 별도 메커니즘을 추가해야 할 수 있다.

# 10장 인터페이스 분리 원치

## 인터페이스를 분리하지 않고 모든 것을 한 곳에 모은 클레스 A'이 있고 이를 참조하는 A,B,C가 있다고 가정하면 이때 A에서 사용하지 않는 코드(B, C)를 A'에서 변경하는 경우 A 또한 다시 배포해야한다.

## ISP와 언어
- 위처럼 소스코드 의존성이 발생하고, 이로 인해 재컴파일 또는 재배포가 강제되는 상황이 무조건 초래된다.
- 동적 타입 언어를 사용하면 정적 타입 언어를 사용할 때보다 유연하며 결합도가 낮은 시스템을 만들 수 있는 이유는 바로 이 때문.

## ISP와 아키텍쳐
- 예를 들어 S 시스템 구축에 참여하고 있는 아키텍트가 있다고 가정 아키텍트는 F라는 프레임워크를 시스템에 도입하기를 원한다. 그리고 f 프레임워크 개발자는 특정한 d 데이터베이스를 반드시 사용하도록 만들었다고 가정해 보자. 따라서 s는 f에 의존하며 f는 다시 d에 의존하게 된다.
- F에는 불필요한 기능 따라서 s와는 전혀 관계없는 기능이 d에 포함된다고 가정하자 그 기능 때문에 d 내부가 변경되면 f를 재배포해야 할 수도 있고 따라서 s가지 재배포해야 할지 모른다. 더 심각한 문제는 d 내부의 기능 중 f와 s에서 불필요한 그 기능에 문제가 발생해도 f와 s에 영향을 준다는 사실

## 정리
- 불필요한 짐을 실은 무언가에 의존하면 예상치도 못한 문제에 빠진다...


# 11장 의존성 역전 원칙

## 의존성 역전 원칙에서 말하는 유연성이 극대화된 시스템이란 소스코드 의존성이 추상에 의존하면 구체에는 의존하지 않는 시스템이다.
## String 클레스는 매우 안정적이다. String 클레스가 변경되는 일은 거의 없으며 있더라도 엄격하게 통제된다. 프로그래머와 아키텍트는 string 클레스에서 변덕스러운 변경이 자주 발생하리라고 염려할 필요가 없다.
## 이러한 이유로 DIP를 노할 때 운영체제나 플랫폼 같이 안정성이 보장된 환경에 대해서는 무시하는 편이다. 우리는 이들 환경에 대한 의존성은 용납하는데 변경되지 않는다면 의존할 수 있다는 사실을 이미 알고 있기 때문이다.
## 우리가 의존하지 않도록 피하고자 하는 것은 바로 변동성이 큰 구체적인 요소다.

## 안정된 추상화
- 인터페이스는 구현체보다 변동성이 낮다
- 실제로 뛰어난 소프트웨어 설계자와 아키텍트라면 인터페이스와 변동성을 낮추기 위해 애쓴다.
- 소프트웨어 아키텍처란 변동성이 큰 구현체에 의존하는 일은 지양하고, 안정된 추상 인터페이스를 선호하는 아키텍처라는 뜻이다.
- 변동성이 큰 구체 클래스를 참조하지 말라.
- 변동성이 큰 구체 클래스로부터 파생하지 말라. (정적 타입 언어에서 상속은 소스 코드에 존재하는 모든 관계 중에서 가장 강력한 동시에 뻣뻣해서 변경하기 어렵다.)
- 구체 함수를 오버라이드 하지 말라 (대체로 구체함수는 소스코드 의존성을 필요로 한다. 따라서 구체 함수를 오버라이드 하면 이러한 의존성을 제거할 수 없게 되며 실제로는 그 의존성을 상속하게 된다.)

### 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라.(DIP 원칙을 다른 방식으로 풀어쓴 것이다.)


## 팩토리
- 추상 팩토리를 사용하여 바람직하지 못한 의존성을 처리할 수 있다.
- 시스템을 두가지 컴포넌트로 분리 -> 하나는 추상 컴포넌트이며 다른 하나는 구체 컴포넌트다. 추상 컴포넌트는 애플리케이션의 모든 고수준 업무 규칙을 포함한다. 구체 컴포넌트는 업무 규칙을 두루기 위해 필요한 모든 세부사항을 포함한다.
- 제어흐름은 소스코드 의존성과는 정반대 방샹으로 곡선을 가로지른다는 점에 주목하자. 소스코드 의존성은 제어흐름과는 반대 방향으로 반대 방향으로 역전된다. 의존성 역전이라고 부른다.
- DIP를 위배하는 클래스들은 적은 수의 구체 컴포넌트 내부로 모을 수 있고, 이를 통해 시스템의 나머지 부분과는 분리할 수 있다.